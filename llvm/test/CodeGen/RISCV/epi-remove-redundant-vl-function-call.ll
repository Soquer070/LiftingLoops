; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+a,+c,+v -verify-machineinstrs \
; RUN:    -no-epi-remove-redundant-vsetvl \
; RUN:    -no-epi-remove-redundant-vsetvl-global  < %s \
; RUN:    | FileCheck --check-prefix=DISABLED %s
; RUN: llc -mtriple=riscv64 -mattr=+m,+f,+d,+a,+c,+v -verify-machineinstrs < %s \
; RUN:    | FileCheck %s

define <vscale x 1 x double> @add1(<vscale x 1 x double>, i64) nounwind {
; DISABLED-LABEL: add1:
; DISABLED:       # %bb.0:
; DISABLED-NEXT:    lui a1, %hi(.LCPI0_0)
; DISABLED-NEXT:    addi a1, a1, %lo(.LCPI0_0)
; DISABLED-NEXT:    fld ft0, 0(a1)
; DISABLED-NEXT:    vsetvli a0, a0, e64,m1
; DISABLED-NEXT:    vfadd.vf v16, v16, ft0
; DISABLED-NEXT:    ret
;
; CHECK-LABEL: add1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lui a1, %hi(.LCPI0_0)
; CHECK-NEXT:    addi a1, a1, %lo(.LCPI0_0)
; CHECK-NEXT:    fld ft0, 0(a1)
; CHECK-NEXT:    vsetvli a0, a0, e64,m1
; CHECK-NEXT:    vfadd.vf v16, v16, ft0
; CHECK-NEXT:    ret
  %3 = call <vscale x 1 x double> @llvm.epi.vfmv.v.f.nxv1f64.f64(double 1.0, i64 %1)
  %4 = call <vscale x 1 x double> @llvm.epi.vfadd.nxv1f64.nxv1f64(<vscale x 1 x double> %0, <vscale x 1 x double> %3, i64 %1)
  ret <vscale x 1 x double> %4
}

declare <vscale x 1 x double> @llvm.epi.vfmv.v.f.nxv1f64.f64(double, i64)

declare <vscale x 1 x double> @llvm.epi.vfadd.nxv1f64.nxv1f64(<vscale x 1 x double>, <vscale x 1 x double>, i64)

define void @foo(double*) nounwind {
; DISABLED-LABEL: foo:
; DISABLED:       # %bb.0:
; DISABLED-NEXT:    addi sp, sp, -32
; DISABLED-NEXT:    sd ra, 24(sp)
; DISABLED-NEXT:    sd s1, 16(sp)
; DISABLED-NEXT:    sd s2, 8(sp)
; DISABLED-NEXT:    add s2, zero, a0
; DISABLED-NEXT:    vsetvli s1, zero, e64,m1
; DISABLED-NEXT:    vsetvli a0, s1, e64,m1
; DISABLED-NEXT:    vle.v v16, (s2)
; DISABLED-NEXT:    srli a0, s1, 1
; DISABLED-NEXT:    call add1
; DISABLED-NEXT:    vsetvli a0, s1, e64,m1
; DISABLED-NEXT:    vse.v v16, (s2)
; DISABLED-NEXT:    ld s2, 8(sp)
; DISABLED-NEXT:    ld s1, 16(sp)
; DISABLED-NEXT:    ld ra, 24(sp)
; DISABLED-NEXT:    addi sp, sp, 32
; DISABLED-NEXT:    ret
;
; CHECK-LABEL: foo:
; CHECK:       # %bb.0:
; CHECK-NEXT:    addi sp, sp, -16
; CHECK-NEXT:    sd ra, 8(sp)
; CHECK-NEXT:    sd s1, 0(sp)
; CHECK-NEXT:    add s1, zero, a0
; CHECK-NEXT:    vsetvli a0, zero, e64,m1
; CHECK-NEXT:    vle.v v16, (s1)
; CHECK-NEXT:    srli a0, a0, 1
; CHECK-NEXT:    call add1
; CHECK-NEXT:    vsetvli a0, zero, e64,m1
; CHECK-NEXT:    vse.v v16, (s1)
; CHECK-NEXT:    ld s1, 0(sp)
; CHECK-NEXT:    ld ra, 8(sp)
; CHECK-NEXT:    addi sp, sp, 16
; CHECK-NEXT:    ret
  %2 = call i64 @llvm.epi.vsetvlmax(i64 3, i64 0)
  %3 = bitcast double* %0 to <vscale x 1 x double>*
  %4 = call <vscale x 1 x double> @llvm.epi.vload.nxv1f64(<vscale x 1 x double>* %3, i64 %2)
  %5 = lshr i64 %2, 1
  %6 = call <vscale x 1 x double> @add1(<vscale x 1 x double> %4, i64 %5)
  call void @llvm.epi.vstore.nxv1f64(<vscale x 1 x double> %6, <vscale x 1 x double>* %3, i64 %2)
  ret void
}

declare i64 @llvm.epi.vsetvlmax(i64, i64)

declare <vscale x 1 x double> @llvm.epi.vload.nxv1f64(<vscale x 1 x double>*, i64)

declare void @llvm.epi.vstore.nxv1f64(<vscale x 1 x double>, <vscale x 1 x double>*, i64)
